// blog.js — Featured + Archive + Single Post Router for /blog and /blog/<slug> import { createClient } from "https://esm.sh/@supabase/supabase-js@2" const SUPABASE_URL = "https://ketluxsokzvlqozcdwxo.supabase.co" const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtldGx1eHNva3p2bHFvemNkd3hvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzNjAzOTIsImV4cCI6MjA3MDkzNjM5Mn0.NCPCOXJ4vD1PYb_sBgoyA6lSvkiRpb8IlA4X8XnltUs" // NOTE: This is a public anon key – make sure RLS is enabled on your tables. export const supabase = createClient(SUPABASE_URL, SUPABASE_KEY) /* ---------- Utilities ---------- */ const $ = (sel) => document.querySelector(sel) const postsEl = $("#posts") const archiveEl = $("#archive") const featuredEl = $("#featured") const singleEl = $("#single") // optional container for single post pages // Build link for a post (prefers slug, falls back to id) const linkFor = (p) => /blog/${encodeURIComponent(p.slug || String(p.id))} // Nice date helper const fmtDate = (d) => { if (!d) return "" const dt = new Date(d) return dt.toLocaleDateString("en-GB", { year: "numeric", month: "long", day: "numeric" }) } /* ---------- Data ---------- */ async function fetchFeaturedPost() { const { data, error } = await supabase .from("posts") .select("id,slug,title,content,description,main_image_url,published_at,created_at,featured") .eq("featured", true) .order("published_at", { ascending: false, nullsFirst: false }) .order("created_at", { ascending: false, nullsFirst: false }) .limit(1) return { data: data?.[0] ?? null, error } } async function fetchAllPosts() { const { data, error } = await supabase .from("posts") .select("id,slug,title,description,main_image_url,published_at,created_at,featured") .order("published_at", { ascending: false, nullsFirst: false }) .order("created_at", { ascending: false, nullsFirst: false }) .order("id", { ascending: false }) return { data, error } } async function fetchPostBySlugOrId(key) { // try slug first if (!key) return { data: null, error: new Error("No slug/id supplied") } // slug path let q = supabase .from("posts") .select("id,slug,title,content,description,main_image_url,published_at,created_at") .eq("slug", key) .limit(1) let { data, error } = await q if (error) return { data: null, error } if (data && data.length) return { data: data[0], error: null } // fallback: numeric id if (/^\d+$/.test(key)) { const res = await supabase .from("posts") .select("id,slug,title,content,description,main_image_url,published_at,created_at") .eq("id", Number(key)) .single() return res } return { data: null, error: new Error("Post not found") } } /* ---------- Includes (header/footer) ---------- */ async function includePartials({ headerSel = "#header", footerSel = "#footer" } = {}) { try { const [header, footer] = await Promise.all([ fetch("/header.html").then(r => r.ok ? r.text() : ""), fetch("/footer.html").then(r => r.ok ? r.text() : ""), ]) const h = document.querySelector(headerSel) const f = document.querySelector(footerSel) if (h) h.innerHTML = header if (f) f.innerHTML = footer } catch (e) { console.error("includePartials failed:", e) } } /* ---------- Archive builder ---------- */ function groupByYearMonth(posts) { const buckets = new Map() for (const p of posts) { const d = p.published_at || p.created_at || null const dt = d ? new Date(d) : null const year = dt ? dt.getFullYear() : "Unknown" const month = dt ? dt.toLocaleString("en-GB", { month: "long" }) : "Unsorted" if (!buckets.has(year)) buckets.set(year, new Map()) const m = buckets.get(year) if (!m.has(month)) m.set(month, []) m.get(month).push(p) } // Sort years desc (numeric & "Unknown" last) const sortedYears = [...buckets.entries()].sort((a, b) => { const [ya, yb] = [a[0], b[0]] if (ya === "Unknown") return 1 if (yb === "Unknown") return -1 return Number(yb) - Number(ya) }) return new Map(sortedYears) } function buildArchive(posts) { if (!archiveEl) return const grouped = groupByYearMonth(posts) archiveEl.innerHTML = "" for (const [year, months] of grouped) { const det = document.createElement("details"); det.open = true const sum = document.createElement("summary"); sum.textContent = year; det.appendChild(sum) const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"] const ordered = monthNames.filter(m => months.has(m)) if (months.has("Unsorted")) ordered.push("Unsorted") for (const m of ordered) { const wrap = document.createElement("div"); wrap.className = "month" const h4 = document.createElement("h4"); h4.textContent = m; wrap.appendChild(h4) const ul = document.createElement("ul"); ul.className = "archive-list" for (const p of months.get(m)) { const li = document.createElement("li") const a = document.createElement("a"); a.href = linkFor(p); a.textContent = p.title || "Untitled" li.appendChild(a); ul.appendChild(li) } wrap.appendChild(ul); det.appendChild(wrap) } archiveEl.appendChild(det) } } /* ---------- Renderers ---------- */ async function renderListPage() { if (postsEl) postsEl.textContent = "Loading…" const [{ data: featured }, { data: all, error }] = await Promise.all([fetchFeaturedPost(), fetchAllPosts()]) if (error) { if (postsEl) postsEl.textContent = "Error loading posts."; return } if (!all || all.length === 0) { if (postsEl) postsEl.innerHTML = <p class="empty">No posts yet.</p> if (archiveEl) archiveEl.innerHTML = <p class="empty">Nothing to archive… yet.</p> if (featuredEl) featuredEl.innerHTML = "" return } const hero = featured || all[0] if (featuredEl) { featuredEl.innerHTML = ${hero.main_image_url ? <img src="${hero.main_image_url}" alt=""> : ""} <div class="featured-content"> <h2>${hero.title ?? "Untitled"}</h2> ${hero.description ? <p>${hero.description}</p> : ""} <a href="${linkFor(hero)}">Read full post →</a> </div> } buildArchive(all) const heroKey = hero.slug ?? hero.id const rest = all.filter(p => (p.slug ?? p.id) !== heroKey) if (postsEl) postsEl.innerHTML = "" for (const p of rest) { const a = document.createElement("a") a.className = "card" a.href = linkFor(p) a.innerHTML = ${p.main_image_url ? <img class="thumb" src="${p.main_image_url}" alt=""> : ""} <div class="title">${p.title ?? "Untitled"}</div> ${p.description ? <p class="desc">${p.description}</p> : ""} postsEl?.appendChild(a) } } async function renderSinglePage(key) { if (!singleEl) { // If your template uses the same containers, clear them and reuse: if (featuredEl) featuredEl.innerHTML = "" if (archiveEl) archiveEl.innerHTML = "" } const target = singleEl || postsEl if (target) target.textContent = "Loading…" const { data: post, error } = await fetchPostBySlugOrId(key) if (error || !post) { if (target) target.textContent = "Post not found."; return } const heroImg = post.main_image_url ? <img class="post-hero" src="${post.main_image_url}" alt=""> : "" const dateStr = fmtDate(post.published_at || post.created_at) if (target) { target.innerHTML = <article class="post"> ${heroImg} <header class="post-header"> <h1>${post.title ?? "Untitled"}</h1> ${dateStr ? <p class="post-meta">${dateStr}</p> : ""} </header> ${post.description ? <p class="post-desc">${post.description}</p> : ""} <div class="post-body">${post.content ?? ""}</div> <p class="back-link"><a href="/blog">← Back to all posts</a></p> </article> } } /* ---------- Tiny Router ---------- */ function getBlogKeyFromPath() { // Supports /blog, /blog/, /blog.html for list // and /blog/<slug-or-id> for single const path = window.location.pathname // Normalise trailing slash if (path === "/blog" || path === "/blog/") return null // If you’re serving the list shell at /blog.html if (path.endsWith("/blog.html")) return null // Try to capture /blog/<key> const m = path.match(/^\/blog\/([^/]+)\/?$/) return m ? decodeURIComponent(m[1]) : null } async function router() { await includePartials() const key = getBlogKeyFromPath() if (key) { await renderSinglePage(key) } else { await renderListPage() } } // Boot router()